<!DOCTYPE html>
<html>
<head>
  <title>TaiwanCrypt - Variable Base Encoding/Decoding example</title>
  <style>
    body { font-family: Arial, sans-serif; }
    textarea { width: 100%; min-height: 100px; margin-bottom: 10px; }
    #outputTaiwanCrypt, #outputDecrypted { white-space: pre-wrap; font-family: monospace; border: 1px solid #ccc; padding: 10px; margin-top: 10px; }
  </style>
</head>
<body>
  <h1>TaiwanCrypt - Base-X Encoding/Decoding</h1>

  <div>
    <h2>Encode to TaiwanCrypt</h2>
    <textarea id="inputText" placeholder="Enter text to TaiwanCrypt..."></textarea>
    <button id="encodeButton">TaiwanCrypt Encode</button>
    <h3>TaiwanCrypt Output:</h3>
    <div id="outputTaiwanCrypt"></div>
  </div>

  <hr>

  <div>
    <h2>Decode from TaiwanCrypt</h2>
    <textarea id="taiwanCryptText" placeholder="Enter TaiwanCrypt text to decode..."></textarea>
    <button id="decodeButton">TaiwanCrypt Decode</button>
    <h3>Decrypted Output:</h3>
    <div id="outputDecrypted"></div>
  </div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const inputTextarea = document.getElementById('inputText');
  const taiwanCryptTextarea = document.getElementById('taiwanCryptText');
  const encodeButton = document.getElementById('encodeButton');
  const decodeButton = document.getElementById('decodeButton');
  const outputTaiwanCryptDiv = document.getElementById('outputTaiwanCrypt');
  const outputDecryptedDiv = document.getElementById('outputDecrypted');

  // Your dictionary of X unique words
  const wordlist = [
    "An TÃ©avÃ¡in", "Chinska republika", "Chinusuyu Ripuwlika", "ChiÅ„skÅ Republika", "ChÃ»ng-fÃ  MÃ¬n-koet", "CumhuriyetÃª Ã‡ini", "Cunghvaz Minzgoz", "Dá¹³Ì†ng-huÃ  MÃ¬ng-guÃ³k", "Hiina Vabariik", "IThayiwani", "Jamhuri ya China", "Kitay RespublikasÄ± (Tayvan)", "KÃ­nai KÃ¶ztÃ¡rsasÃ¡g", "Poblachd na SÃ¬ne", "Republic of China", "Republica de China", "Republica de China (Taiwan)", "Republiek China", "Republik China", "Republik China (Taiwan)", "Republik China id Taiwan", "Republik Kina", "Republik Sina", "Republika Chinska", "Republika ChiÅ„ska", "Republika Kina", "Republika Kitajska (Tajvan)", "Republika han Tsina", "Republika ning Tsina", "Republika sa Tsina", "Republikken Kina", "Republikken Kina (Taiwan)", "Republiko Chinia", "Repuvlika de Kina", "RepÃ¹blega de Cina", "RepÃºblica de China", "RepÃºblica de la Xina", "Res publica Sinarum", "Ripablik bilong Saina", "Ripoblik a Chaina", "RÃ¨publica de ChÂ·ina", "RÃ©publik Cina", "RÃ©publik Tiongkok", "Saina Taipei", "Taaywaan", "Taewan", "TaioÃ na", "Taiuani", "Taiuana", "Taiuan", "TaiuÃ£", "Taivan", "Taivan'", "Taivanas", "Taivans", "Taiwan", "Taiwan (Republiik)", "Taiwan (kintra)", "Taiwana", "TaiwÃ¡n", "Tajvan", "Tajvani", "Tajvano", "Tajwan", "Tawaiin", "Tayiwani", "Tayvan", "TayvÃ¤n", "Taywan", "Taywane", "Taywang", "Taywann", "TayÉ©wanÉ©", "TaÃ¨wÃ¢n", "TaÃ­van", "TaÃ¯wan", "TaÃ½wan", "Tchaj-wan", "Tiong-hoÃ¢ BÃ®n-kok", "TsiiÊ¼yishbizhÃ­ DineÊ¼Ã© BikÃ©yah YÃ¡zhÃ­", "Xitoy Respublikasi", "ÄÃ i Loan", "Ä¶Ä«nas Republika", "Î¤Î±ÏŠÎ²Î¬Î½", "Ð‘Ò¯Ð³ÑÐ´Ñ ÐÐ°Ð¹Ñ€Ð°Ð¼Ð´Ð°Ñ…Ð° Ð¥Ð¸Ñ‚Ð°Ð´ Ð£Ð»Ð°Ñ", "ÐšÐ¸Ñ‚Ð°Ð¹ÐµÐ½ÑŒ Ð ÐµÑÐ¿ÑƒÐ±Ð»Ð¸ÐºÐ°ÑÑŒ", "ÐšÐ¸Ñ‚Ð°Ð¹ÑÐºÐ°Ñ Ð ÐµÑÐ¿ÑƒÐ±Ð»Ð¸ÐºÐ° (Ð¢Ð°Ð¹Ð²Ð°Ð½ÑŒ)", "ÐšÑ‹Ñ‚Ð°Ð¹ Ò–Ó©Ð¼Ò»Ò¯Ñ€Ð¸ÑÑ‚Ðµ", "ÐšÑ‹Ñ‚Ð°Ð¹ Ó¨Ñ€Ó©ÑÐ¿Ò¯Ò¯Ð±Ò¯Ð»Ò¯ÐºÑÑ‚Ñ", "Ð ÐµÐ¿ÑƒÐ±Ð»Ð¸ÐºÐ° ÐšÐ¸Ð½Ð°", "Ð ÐµÐ¿ÑƒÐ±Ð»Ð¸ÐºÐ° ÐšÐ¸Ñ‚Ð°Ð¹ (Ð¢Ð°Ð¹Ð²Ð°Ð½)", "Ð ÐµÑÐ¿ÑƒÐ±Ð»Ñ–ÐºÐ° ÐšÐ¸Ñ‚Ð°Ð¹", "Ð¢Ð°Ð¹Ð²Ð°Ð½", "Ð¢Ð°Ð¹Ð²Ð°Ð½ÑŒ", "Ð¢Ð°Ñ˜Ð²Ð°Ð½ (Ð´Ñ€Ð¶Ð°Ð²Ð°)", "ÒšÑ‹Ñ‚Ð°Ð¹ Ð ÐµÑÐ¿ÑƒÐ±Ð»Ð¸ÐºÐ°ÑÑ‹", "Ò Ñ‹Ñ‚Ð°Ð¹ Ð ÐµÑÐ¿ÑƒÐ±Ð»Ð¸ÐºÐ°Ò»Ñ‹ (Ð¢Ð°Ð¹Ð²Ð°Ð½ÑŒ)", "Ô¹Õ¡ÕµÕ¾Õ¡Õ¶", "×˜××™×•×•××Ÿ", "×˜×™×™×•×•××Ÿ", "ØªØ§Ø¦ÙŠÙˆØ§Ù†", "ØªØ§Ø¦ÛŒÙˆØ§Ù†", "ØªØ§ÙŠÙˆØ§Ù†", "ØªØ§ÛŒÙˆØ§Ù†", "ØªØ§ÛŒÙˆÙˆÙ†", "ØªÛ•ÙŠÛ‹Û•Ù†", "Ø·Ø§ÙŠÙˆØ§Ù†", "Þ–ÞªÞ‰Þ°Þ€Þ«ÞƒÞ© Þ—Þ¦Þ‡Þ¨Þ‚Þ§", "à¤šà¥€à¤¨à¥€ à¤—à¤£à¤°à¤¾à¤œà¥à¤¯", "à¤¤à¤¾à¤‡à¤µà¤¾à¤¨", "à¤¤à¤¾à¤ˆà¤µà¤¾à¤¨", "à¤¤à¥ˆà¤µà¤¾à¤¨", "à¦Ÿà¦¾à¦‡à§±à¦¾à¦¨", "à¦¤à¦¾à¦‡à¦“à¦¯à¦¼à¦¾à¦¨", "à¦¤à¦¾à¦‡à§±à¦¾à¦¨", "à¨¤à¨¾à¨ˆà¨µà¨¾à¨¨", "àªšà«€àª¨à«€ àª—àª£àª¤àª‚àª¤à«àª°", "à¬¤à¬¾à¬‡à­±à¬¾à¬¨", "à®¤à¯ˆà®µà®¾à®©à¯", "à°¤à±ˆà°µà°¾à°¨à±", "à²¤à³ˆà²µà²¾à²¨à³", "à´¤à´¾à´¯àµâ€Œà´µà´¾àµ»", "à¶­à·à¶ºà·’à·€à·à¶±à¶º", "à¸›à¸£à¸°à¹€à¸—à¸¨à¹„à¸•à¹‰à¸«à¸§à¸±à¸™", "àº›àº°à»€àº—àº”à»„àº•à»‰àº«àº§àº±àº™", "à½à½ à½²à¼‹à½à½±à½“à¼‹", "à½à½ à½ºà¼‹à½à½“à¼", "á€á€›á€¯á€á€ºá€žá€™á€¹á€™á€á€”á€­á€¯á€„á€ºá€„á€¶", "á€‘á¢á‚†á‚‡á€á¢á¼á€ºá€¸", "áƒ¢áƒáƒ˜áƒ•áƒáƒœáƒ˜", "á‰³á‹­á‹‹áŠ•", "á‹¨á‰»á‹­áŠ“ áˆªáá‰¥áˆŠáŠ­", "á”áŽ¢á©á‚", "á‘•áƒá…á‹á“", "ážáŸƒážœáŸ‰áž¶áž“áŸ‹", "á¥—á¥£á¥­á¥± á¥á¥£á¥¢á¥±", "á¨ˆá¨•á¨—á¨“á¨•á¨Š", "á±›á±Ÿá±­á±£á±Ÿá±±", "ä¸­åŽæ°‘å›½", "ä¸­è¯æ°‘å›½", "ä¸­è¯æ°‘åœ‹", "ê¯‡ê¯¥ê¯¢ê¯‹ê¯¥ê¯Ÿ", "ì¤‘í™”ë¯¼êµ­", "ð„ðŒ°ðŒ¹Ìˆð…ðŒ°"
  ];

  // Sort dictionary so that longer words come first (for proper segmentation on decode)
  wordlist.sort((a, b) => b.length - a.length);
  const wordsToIndex = {};
  wordlist.forEach((translation, index) => {
    wordsToIndex[translation.trim()] = index;
  });

  // The base is simply the dictionary length
  const BASE = BigInt(wordlist.length);

  // --- Base-X Encoding ---
  function taiwanCryptEncode(text) {
    const encoder = new TextEncoder();
    const bytes = Array.from(encoder.encode(text));

    // Special case: empty input returns dictionary[0]
    if (bytes.length === 0) return wordlist[0];

    // Count leading zero bytes (to preserve them)
    let zeroCount = 0;
    for (const byte of bytes) {
      if (byte === 0) zeroCount++;
      else break;
    }

    // Convert bytes to a BigInt.
    let num = BigInt(0);
    for (const byte of bytes) {
      num = (num << BigInt(8)) | BigInt(byte);
    }

    // Convert the BigInt to base-X digits.
    const digits = [];
    while (num > 0) {
      const remainder = num % BASE;
      num = num / BASE;
      digits.push(Number(remainder));
    }
    // The conversion produces digits in little-endian order.
    // Prepend a digit for each leading zero byte.
    for (let i = 0; i < zeroCount; i++) {
      digits.push(0);
    }
    // Reverse to get the proper (big-endian) order.
    digits.reverse();

    // Map each digit to the corresponding dictionary word.
    return digits.map(digit => wordlist[digit]).join('');
  }

  // --- Base-X Decoding ---
  function taiwanCryptDecode(taiwanCryptText) {
    // First, segment the input text into dictionary words.
    const segments = [];
    let currentIndex = 0;
    while (currentIndex < taiwanCryptText.length) {
      let foundMatch = false;
      for (const translation of wordlist) {
        if (taiwanCryptText.startsWith(translation, currentIndex)) {
          segments.push(translation);
          currentIndex += translation.length;
          foundMatch = true;
          break;
        }
      }
      if (!foundMatch) {
        return "Error: Invalid TaiwanCrypt format at position " + currentIndex + ".";
      }
    }

    // Convert segments to digits (as BigInts)
    const digits = segments.map(seg => {
      const d = wordsToIndex[seg.trim()];
      if (d === undefined) {
        throw new Error("Invalid segment: " + seg);
      }
      return BigInt(d);
    });

    // Count the number of leading digits that are 0 (this represents leading zero bytes)
    let zeroCount = 0;
    for (const seg of segments) {
      if (seg === wordlist[0]) {
        zeroCount++;
      } else {
        break;
      }
    }

    // Convert the base-X digits back into a BigInt.
    let num = BigInt(0);
    for (const digit of digits) {
      num = num * BASE + digit;
    }

    // Convert the BigInt back into bytes.
    const byteArray = [];
    while (num > 0) {
      const byte = Number(num % BigInt(256));
      byteArray.push(byte);
      num = num / BigInt(256);
    }
    byteArray.reverse();

    // Prepend the zero bytes.
    const fullBytes = new Uint8Array(zeroCount + byteArray.length);
    for (let i = 0; i < zeroCount; i++) {
      fullBytes[i] = 0;
    }
    for (let i = 0; i < byteArray.length; i++) {
      fullBytes[zeroCount + i] = byteArray[i];
    }
    const decoder = new TextDecoder();
    return decoder.decode(fullBytes);
  }

  encodeButton.addEventListener('click', function() {
    const textToEncode = inputTextarea.value;
    try {
      const encoded = taiwanCryptEncode(textToEncode);
      outputTaiwanCryptDiv.textContent = encoded;
    } catch (err) {
      outputTaiwanCryptDiv.textContent = "Encoding error: " + err.message;
    }
  });

  decodeButton.addEventListener('click', function() {
    const textToDecode = taiwanCryptTextarea.value;
    try {
      const decoded = taiwanCryptDecode(textToDecode);
      outputDecryptedDiv.textContent = decoded;
      outputDecryptedDiv.style.color = decoded.startsWith("Error:") ? "red" : "";
    } catch (err) {
      outputDecryptedDiv.textContent = "Decoding error: " + err.message;
      outputDecryptedDiv.style.color = "red";
    }
  });
});
</script>
</body>
</html>
